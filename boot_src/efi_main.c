#include <efi.h>
#include <efilib.h>
#include "efiConsoleControl.h"

#define ASSERT_NO_EFI_ERROR() if(status != EFI_SUCCESS) goto efi_abort;

static void PrintStr(CHAR16* fmt) {
    uefi_call_wrapper(ST->ConOut->ClearScreen, 1, ST->ConOut);
    uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, fmt);
}

static void wait_forever() {
    while(TRUE) {
        __asm__ volatile("nop");
    }
}

EFI_STATUS EFIAPI efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) {
    EFI_STATUS status;
    ST = SystemTable;
    BS = ST->BootServices;

    BS->SetWatchdogTimer(4, 0, 0, NULL); // reset the system after 4 seconds if BS->ExitBootServices has not been called.
    ST->ConOut->Reset(ST->ConOut, FALSE); // clear screen and reset cursor to (0,0)

    // load the image protocol of this image; an image is essentially the executable PE file with elf subsystem generated by the linker
    EFI_LOADED_IMAGE_PROTOCOL* loaded_image = NULL;
    EFI_GUID loaded_image_guid = EFI_LOADED_IMAGE_PROTOCOL_GUID;
    status = BS->HandleProtocol(ImageHandle, &loaded_image_guid, (VOID**)&loaded_image);
    ASSERT_NO_EFI_ERROR();

    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* file_system = NULL;
    EFI_GUID file_system_guid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
    status = BS->HandleProtocol(loaded_image->DeviceHandle, &file_system_guid, (VOID**)&file_system);
    ASSERT_NO_EFI_ERROR();
	
    EFI_FILE_HANDLE root_dir;
    status = file_system->OpenVolume(file_system, &root_dir);
    ASSERT_NO_EFI_ERROR();

    EFI_FILE_HANDLE file;
    status = root_dir->Open(root_dir, &file, L"Test.abc", EFI_FILE_MODE_READ, 0);
    ASSERT_NO_EFI_ERROR();

    PrintStr(L"Still running...\n");
    wait_forever();

efi_abort:
    // If we reach this the efi program has failed to call into the kernel
    PrintStr(L"EFI Program failed to call into the kernel.\n");
    return EFI_ABORTED;
}
